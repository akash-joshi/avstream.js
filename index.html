<head>
    <html lang="en">
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<meta charset="utf-8">
	<link rel="stylesheet" type="text/css" href="style.css">
	<meta name="viewport" content="width=device-width, initial-scale=1">

	<title>codefeathers/up-serve: A cli tool to quickly create and manage nginx server blocks.</title>
	<meta content="up-serve - A cli tool to quickly create and manage nginx server blocks." property="og:description">
	<link rel="canonical" href="https://github.com/codefeathers/up-serve" data-pjax-transient="">
	<meta name="theme-color" content="#1e2327">
</head>
<h1 id="audio-video-stream-js">Audio-Video-Stream.js</h1>
<div align="center">
	<div>
		<img src="img.png" alt="AVStrean">
	</div>
</div>

</p>
<p> A small 500 byte JavaScript library leveraging the native MediaRecorder API to allow streaming of audio or video files to server. </p>
<p> It works by looping the MediaRecorder every <strong>x</strong> milliseconds, which can be used to generate and stream a file at every loop step.</p>
<h2 id="usage">Usage</h2>
<p>Including script in browser :</p>
<pre><code>&lt;script src=&quot;https://unpkg.com/avstream.js/avstream.min.js&quot;&gt;&lt;/script&gt;
</code></pre><p>To use functions in your JS file :</p>
<pre><code>const { startStream, stopStream } = AVStream
</code></pre><h2 id="functions">Functions</h2>
<p>1) <code>startStream(mediaRecorder,time)</code> </p>
<p><em>startStream</em> takes your <strong>mediaRecorder</strong> variable, and <strong>time</strong> in milliseconds. The MediaRecorder is restarted according to the time you provide.</p>
<p>This causes <code>mediaRecorder.onStop()</code> to be called every <strong>time</strong> milliseconds. So, you can write your blob creation and server call in that function.</p>
<p>2) <code>stopStream()</code> </p>
<p><em>stopStream</em> stops the stream.</p>
<h2 id="tutorial">Tutorial</h2>
<pre><code class="lang-javascript">// Record &amp; Stop buttons of your HTML
const record = document.querySelector(&#39;#recordbutton&#39;)
const stop = document.querySelector(&#39;#stopbutton&#39;)

// Importing necessary variables
const { MediaRecorder, Blob } = window
const {startStream,stopStream} = AVStream

// Checking if browser allows getUsermedia
if (navigator.mediaDevices.getUserMedia) {
  console.log(&#39;getUserMedia supported.&#39;)

  // Setting constraints for MediaRecorder
  const constraints = { audio: true, video: false }

  // Declare chunks for our blob
  let chunks = [];

  const onSuccess = (stream) =&gt; {

    // Creating a MediaRecorder object
    const mediaRecorder = new MediaRecorder(stream)

    // if record button clicked, call startstream
    // with our mediarecorder object and a 1000ms loop
    record.onclick = () =&gt; {
      startStream(mediaRecorder,1000)
      console.log(mediaRecorder.state)
      console.log(&#39;recorder started&#39;)
    }

    // stop stream if stop button clicked
    stop.onclick = () =&gt; {
      stopStream()
      console.log(mediaRecorder.state)
      console.log(&#39;recorder stopped&#39;)
    }

    // Blob created and streamed to server
    // Looped according to time we specify
    mediaRecorder.onstop = () =&gt; {
      console.log(&#39;data available after MediaRecorder.stop() called.&#39;)

      // Create file from chunks
      const blob = new Blob(chunks, { &#39;type&#39; : &#39;audio/wav&#39; })

      // Write code to send blob to server here

      // Clear chunks for new file
      chunks = [];
    }

    // Push chunks when data is available
    mediaRecorder.ondataavailable = e =&gt; chunks.push(e.data);
  }

  // Promise call to start our code
  navigator.mediaDevices.getUserMedia(constraints).then(onSuccess).catch((err)=&gt;{console.error(err)})
} else {
  console.error(&#39;getUserMedia not supported on your browser!&#39;)
}
</code></pre>
<h2 id="license">License</h2>
<p>The MIT License (MIT)</p>